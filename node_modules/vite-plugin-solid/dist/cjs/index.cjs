'use strict';

var core = require('@babel/core');
var ts = require('@babel/preset-typescript');
var solid = require('babel-preset-solid');
var fs = require('fs');
var module$1 = require('module');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var ts__default = /*#__PURE__*/_interopDefaultLegacy(ts);
var solid__default = /*#__PURE__*/_interopDefaultLegacy(solid);

/**
 * Returns the object type of the given payload
 *
 * @param {*} payload
 * @returns {string}
 */
function getType(payload) {
  return Object.prototype.toString.call(payload).slice(8, -1);
}
/**
 * Returns whether the payload is a plain JavaScript object (excluding special classes or objects with other prototypes)
 *
 * @param {*} payload
 * @returns {payload is PlainObject}
 */


function isPlainObject(payload) {
  if (getType(payload) !== 'Object') return false;
  return payload.constructor === Object && Object.getPrototypeOf(payload) === Object.prototype;
}
/**
 * Returns whether the payload is an array
 *
 * @param {any} payload
 * @returns {payload is any[]}
 */


function isArray(payload) {
  return getType(payload) === 'Array';
}
/**
 * Returns whether the payload is a Symbol
 *
 * @param {*} payload
 * @returns {payload is symbol}
 */


function isSymbol(payload) {
  return getType(payload) === 'Symbol';
}

/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

function __spreadArray(to, from) {
  for (var i = 0, il = from.length, j = to.length; i < il; i++, j++) to[j] = from[i];

  return to;
}
/* eslint-disable @typescript-eslint/explicit-module-boundary-types */


function concatArrays(originVal, newVal) {
  if (isArray(originVal) && isArray(newVal)) {
    // concat logic
    return originVal.concat(newVal);
  }

  return newVal; // always return newVal as fallback!!
}

function assignProp(carry, key, newVal, originalObject) {
  var propType = {}.propertyIsEnumerable.call(originalObject, key) ? 'enumerable' : 'nonenumerable';
  if (propType === 'enumerable') carry[key] = newVal;

  if (propType === 'nonenumerable') {
    Object.defineProperty(carry, key, {
      value: newVal,
      enumerable: false,
      writable: true,
      configurable: true
    });
  }
}

function mergeRecursively(origin, newComer, compareFn) {
  // always return newComer if its not an object
  if (!isPlainObject(newComer)) return newComer; // define newObject to merge all values upon

  var newObject = {};

  if (isPlainObject(origin)) {
    var props_1 = Object.getOwnPropertyNames(origin);
    var symbols_1 = Object.getOwnPropertySymbols(origin);
    newObject = __spreadArray(__spreadArray([], props_1), symbols_1).reduce(function (carry, key) {
      var targetVal = origin[key];

      if (!isSymbol(key) && !Object.getOwnPropertyNames(newComer).includes(key) || isSymbol(key) && !Object.getOwnPropertySymbols(newComer).includes(key)) {
        assignProp(carry, key, targetVal, origin);
      }

      return carry;
    }, {});
  } // newObject has all properties that newComer hasn't


  var props = Object.getOwnPropertyNames(newComer);
  var symbols = Object.getOwnPropertySymbols(newComer);

  var result = __spreadArray(__spreadArray([], props), symbols).reduce(function (carry, key) {
    // re-define the origin and newComer as targetVal and newVal
    var newVal = newComer[key];
    var targetVal = isPlainObject(origin) ? origin[key] : undefined; // When newVal is an object do the merge recursively

    if (targetVal !== undefined && isPlainObject(newVal)) {
      newVal = mergeRecursively(targetVal, newVal, compareFn);
    }

    var propToAssign = compareFn ? compareFn(targetVal, newVal, key) : newVal;
    assignProp(carry, key, propToAssign, newComer);
    return carry;
  }, newObject);

  return result;
}

function mergeAndConcat(object) {
  var otherObjects = [];

  for (var _i = 1; _i < arguments.length; _i++) {
    otherObjects[_i - 1] = arguments[_i];
  }

  return otherObjects.reduce(function (result, newComer) {
    return mergeRecursively(result, newComer, concatArrays);
  }, object);
}

var babel = ({
  types: t
}) => {
  return {
    name: "Solid Refresh",
    visitor: {
      ExportDefaultDeclaration(path, {
        opts
      }) {
        if (path.hub.file.metadata.processedHot) return;
        if (path.hub.file.opts.parserOpts.sourceFileName && !path.hub.file.opts.parserOpts.sourceFileName.endsWith(".jsx") && !path.hub.file.opts.parserOpts.sourceFileName.endsWith(".tsx")) return;
        if (opts.bundler === "vite") opts.bundler = "esm";
        path.hub.file.metadata.processedHot = true;
        const decl = path.node.declaration;
        const HotComponent = t.identifier("$HotComponent");
        const HotImport = t.identifier("_$hot");
        const pathToHot = opts.bundler !== "esm" ? t.memberExpression(t.identifier("module"), t.identifier("hot")) : t.memberExpression(t.memberExpression(t.identifier("import"), t.identifier("meta")), t.identifier("hot"));
        const rename = t.variableDeclaration("const", [t.variableDeclarator(HotComponent, t.isFunctionDeclaration(decl) ? t.functionExpression(decl.id, decl.params, decl.body) : decl)]);
        let replacement;

        if (opts.bundler === "esm") {
          const handlerId = t.identifier("_$handler");
          const componentId = t.identifier("_$Component");
          replacement = [t.importDeclaration([t.importSpecifier(HotImport, t.identifier(opts.bundler || "standard"))], t.stringLiteral("solid-refresh")), t.exportNamedDeclaration(rename), t.variableDeclaration("const", [t.variableDeclarator(t.objectPattern([t.objectProperty(handlerId, handlerId, false, true), t.objectProperty(componentId, componentId, false, true)]), t.callExpression(HotImport, [HotComponent, t.unaryExpression("!", t.unaryExpression("!", pathToHot))]))]), t.ifStatement(pathToHot, t.expressionStatement(t.callExpression(t.memberExpression(pathToHot, t.identifier("accept")), [handlerId]))), t.exportDefaultDeclaration(componentId)];
        } else {
          replacement = [t.importDeclaration([t.importSpecifier(HotImport, t.identifier(opts.bundler || "standard"))], t.stringLiteral("solid-refresh")), rename, t.exportDefaultDeclaration(t.callExpression(HotImport, [HotComponent, pathToHot]))];
        }

        path.replaceWithMultiple(replacement).forEach(declaration => path.scope.registerDeclaration(declaration));
      }

    }
  };
};

const require$1 = module$1.createRequire((typeof document === 'undefined' ? new (require('u' + 'rl').URL)('file:' + __filename).href : (document.currentScript && document.currentScript.src || new URL('index.cjs', document.baseURI).href)));

const runtimePublicPath = '/@solid-refresh';

const runtimeFilePath = require$1.resolve('solid-refresh/dist/solid-refresh.mjs');

const runtimeCode = fs.readFileSync(runtimeFilePath, 'utf-8');
/** Configuration options for vite-plugin-solid. */

function solidPlugin(options = {}) {
  let needHmr = false;
  return {
    name: 'solid',
    enforce: 'pre',

    config(userConfig, {
      command
    }) {
      var _userConfig$resolve;

      // We inject the dev mode only if the user explicitely wants it or if we are in dev (serve) mode
      const replaceDev = options.dev === true || options.dev !== false && command === 'serve'; // TODO: remove when fully removed from vite

      const legacyAlias = normalizeAliases(userConfig.alias);
      if (!userConfig.resolve) userConfig.resolve = {};
      userConfig.resolve.alias = [...legacyAlias, ...normalizeAliases((_userConfig$resolve = userConfig.resolve) === null || _userConfig$resolve === void 0 ? void 0 : _userConfig$resolve.alias)];
      const nestedDeps = ['solid-js', 'solid-js/web', 'solid-js/store', 'solid-js/html', 'solid-js/h'];
      return mergeAndConcat(userConfig, {
        /**
         * We only need esbuild on .ts or .js files.
         * .tsx & .jsx files are handled by us
         */
        esbuild: {
          include: /\.ts$/
        },
        resolve: {
          conditions: ['solid', ...(replaceDev ? ['development'] : [])],
          dedupe: nestedDeps,
          alias: [{
            find: /^solid-refresh$/,
            replacement: runtimePublicPath
          }]
        },
        optimizeDeps: {
          include: nestedDeps
        }
      });
    },

    configResolved(config) {
      needHmr = config.command === 'serve' && !config.isProduction && options.hot !== false;
    },

    resolveId(id) {
      if (id === runtimePublicPath) return id;
    },

    load(id) {
      if (id === runtimePublicPath) return runtimeCode;
    },

    async transform(source, id, ssr) {
      if (!/\.[jt]sx/.test(id)) return null;
      let solidOptions;

      if (options.ssr) {
        if (ssr) {
          solidOptions = {
            generate: 'ssr',
            hydratable: true
          };
        } else {
          solidOptions = {
            generate: 'dom',
            hydratable: true
          };
        }
      } else {
        solidOptions = {
          generate: 'dom',
          hydratable: false
        };
      }

      const opts = {
        filename: id,
        presets: [[solid__default['default'], { ...solidOptions,
          ...(options.solid || {})
        }]],
        plugins: needHmr ? [[babel, {
          bundler: 'vite'
        }]] : []
      };

      if (id.includes('tsx')) {
        opts.presets.push(ts__default['default']);
      } // Default value for babel user options


      let babelUserOptions = {};

      if (options.babel) {
        if (typeof options.babel === 'function') {
          const babelOptions = options.babel(source, id, ssr);
          babelUserOptions = babelOptions instanceof Promise ? await babelOptions : babelOptions;
        } else {
          babelUserOptions = options.babel;
        }
      }

      const babelOptions = mergeAndConcat(babelUserOptions, opts);
      const {
        code,
        map
      } = await core.transformAsync(source, babelOptions);
      return {
        code,
        map
      };
    }

  };
}
/**
 * This basically normalize all aliases of the config into
 * the array format of the alias.
 *
 * eg: alias: { '@': 'src/' } => [{ find: '@', replacement: 'src/' }]
 */

function normalizeAliases(alias = []) {
  return Array.isArray(alias) ? alias : Object.entries(alias).map(([find, replacement]) => ({
    find,
    replacement
  }));
}

module.exports = solidPlugin;
//# sourceMappingURL=index.cjs.map
